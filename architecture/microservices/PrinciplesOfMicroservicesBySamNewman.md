《微服务设计》，Building Microservices，作者Sam Newman
[youtube讲座链接](https://www.youtube.com/watch?v=PFQnNFe27kU)

# 第一章 微服务
微服务强调内聚性，根据Robert C. Martin对单一职责的论述：“把因相同原因而变化的东西放在一起，而把因不同原因而变化的东西分离开来”强调了内聚性。

微服务是独立的服务，并且根据业务边界来确定服务的边界。注意，这里强调的是服务边界，而不是技术边界。传统的如N层架构，MVC架构都是基于技术边界来划分，这种分法看来是不适合划分微服务的。



微服务强调微，微即是小，多小的代码量能称为微服务。按澳大利亚RealEstate.com.au的John Eaves认为，一个微服务应该可以在两周内完全重写。作者给出的回答太含糊：“足够小即可，不要过小。”相比之下，前者的定义更好度量。后者的定义颇为主观。另外，一个微服务对应一个小团队，团队大的话就说明微服务不够微。这又归结到团队大小的度量问题，那么团队多少人算大，多少人算小呢。有一个两个Pizza的论断。一个小团队点的外卖应该两个Pizza就够了。



微服务的自治性。确保微服务的隔离性：

1. 服务之间只通过网络通信。这样能够使得服务可以独立修改，不会因为修改一个服务内部的实现而导致另外的服务不可用或跟着修改（这里指的是修改内部实现，而不是对外部接口的修改）。

2. 服务对外提供的API形式保持技术独立性。这是为了不限制其它服务的实现技术，如编程语言，操作系统等，无需与服务提供方的实现保持一致。



微服务带来的益处：

1. 技术异构性。根据微服务所对应的业务选择技术，而不必受限于其依赖的服务所实现的技术。容易保持系统中的异构架构。而且由于架构的异构性，并且服务的修改或重构对其它服务没有影响（在保证服务接口不变的情况下），因此可以对其中的一个或部分服务尝试新技术。

当然，异构架构和新技术的尝试都是有限制的，无节制的过多的使用太多不同的技术会带来更多的复杂性。过多的操作系统种类，过多的语言，过多的运行环境与应用框架等等。

2. 弹性。这里的弹性指的是单点故障不会导致整个系统故障。单块系统中某组件故障后，很容易导致级联故障，从而使得系统不可用，解决方法可以通过多个机器节点上同时部署相同实例避免单点故障。而微服务本身就是通过网络隔离，不会像在一个机器中的单块系统那样产生连锁反应。由于微服务在每次进行外部调用时，应该会自然地考虑到外部服务不可用的情况处理。而单块系统中API调用时则很难对每次调用考虑周全，并且经常会引发级联故障。

3. 扩展。微服务对单块系统进行了切分，使得可以对相应的瓶颈微服务进行多实例部署来扩展，而不必整个单块系统扩展。对整个单块系统的扩展显然要比只对其中的一部分进行扩展要消耗更多的机器资源，因为好钢并不是全部用在刀刃上。

4. 简化部署。由于微服务功能单一，隔离性好，更改后部署如果出现问题很容易定位，也容易快速回滚。单块系统中牵一发动全身，害怕局部改动对全局产生重大负面影响，因此部署需要做足充分的准备工作。

5. 与组织结构相匹配。分布式的大团队由于沟通、组织等问题，没有小团队的效率高。因此微服务的设计理念和小团队的理念很匹配，可以提高生产率和质量。

6. 可组合性。单块系统由于内部耦合比微服务之间耦合紧密的多，因此想通过组合内部功能完成其它系统功能，比微服务的组合性要差很多。

7. 对可替代性的优化。单块系统想要重写以改进性能，比微服务改写某个服务提升性能要复杂困难许多。



面向服务架构（SOA，Service-Oriented Architecture）是一种方法，在现实中实施并不好。面临通信协议选择，服务粒度确定，第三方中间件选择等问题。可以把微服务架构认为是SOA的一种特定方法。



其它分解技术还有共享库和模块，

1. 共享库：要使用共享库必须得选择相同的实现语言或者至少在同一个平台，丧失了技术独立性。如果是静态库，则每次静态库发生变化，使用的软件又需要重新编译和部署，影响关联颇大。而且，由于进程内调用API，使得级联故障发生的可能性大增。当然，共享库即使在微服务中，也是有生存空间的。例如，很多不同领域的业务都使用该功能，就可以将该功能作为共享库给各个微服务使用。

2. 模块：一些语言提供了模块分解技术如Erlang，它的模块化能力非常牛，支持对模块进行停止、重启或热升级等。但你只能使用Erlang，并且也存在故障级联的问题。语言之外就是OSGI（Open Source Gateway Initiative）了，它过于强调模块生命周期管理了，而生命周期管理在实际项目中用处并不大。而且，一个进程内也导致模块耦合度太高。OSGI带来的复杂度远大于带来的好处。

微服务不是银弹，它天然是分布式系统架构，因此会伴随着分布式系统的复杂性。需要考虑部署、测试、监控、扩展、保持弹性、分布式事务、CAP问题等等

# 第二章 演化式架构师
软件行业中的架构师和建筑行业中的建筑师在英文中都是architect一词，架构师这个概念应该也是从建筑业借用过来的，但两个角色不能简单类比。建筑师面临的物理规律和需求都是确定性的，而软件的架构师没有坚实的物理规律可以依靠，更要面对可能不断变化的需求，因此想要依靠设计大量图表和文档创建一个如同卢浮宫金字塔一样完美的软件系统方案，是难以奏效的。



与其比作建筑师，比作城市规划师可能会贴切一些。城市规划师规划城市中不同区域的功能（生活区、工业区、办公区等），而并不去对单个楼做规划设计。城市会不断变化和改造，但大部分时候区域功能是不变的。同样，架构师应对用户的需求变更， 应该是做一个允许变化的计划，而不是对未来的变化进行预测，因为对未来的预测常常会失败。要允许变化，就不能做出过于详尽的设计。架构师不仅要考虑终端用户，也要将开发人员和运维人员作为系统的用户，他们也是参与者。Frank Buschmann说：架构师的职责之一就是保证该系统适合开发人员在其上工作

# 第三章 如何建模服务
好的服务是松耦合和高内聚的。这两个词在很多地方都用到了，那么在微服务中分别指什么呢？松耦合指的是服务之间耦合度低，修改一个服务不用导致另一个服务跟着修改。高内聚指的是服务内部，相关的行为都聚集在一个服务里，而不是分散在不同服务中，这样需要修改一个行为时，只要修改一个微服务即可。



限界上下文（bounded context）来自Eric Evans的《领域驱动设计》一书，用来对现实世界领域进行建模。作者比较认同的对该词比较好的定义是“一个由显式边界限定的特定职责”。显示边界是外部与它交互的必经之路。



要能找到限界上下文之间的共享模型，其内部和外部的表现形式往往是不一样的。应该共享特定的模型，而不是共享表示，从而避免紧耦合。



单块系统中的模块可以较好地转化为微服务。不要过早地划分微服务，要等到服务边界清晰以后再进行。



对微服务建模时，要首先考虑其业务功能，再考虑其数据。如果只考虑数据，则常常建模为CRUD这种贫血服务。



根据业务边界，结合组织结构，由粗粒度到细粒度地逐步划分限界上下文

# 第四章 集成
1. 寻找理想的集成技术

避免破坏性修改。例如，响应增加字段不影响服务方。

保证API技术的无关性。微服务之间通信方式的技术无关性很重要。

使你的服务易于消费方使用。利于消费方使用任何技术来用你的服务。

隐藏内部实现细节。暴露内部实现会导致消费方去耦合内部实现，因此当修改内部实现时造成消费方不必要的修改。不要采用倾向于暴露内部细节的技术。



2. 为用户创建接口



3. 共享数据库。基于表的共享，会使得服务消费者看到内部实现，无法实现隐藏内部细节。另外，服务实现绑定了数据库技术，导致服务消费者也必须要使用同样的数据库，无法带来技术开放性。因此，避免使用共享数据库。



4. 同步与异步

同步通信的协作风格是请求/响应式，异步通信的风格是基于事件。适合用异步通信的场景：运行时间长的任务、低延时的任务、移动网络及设备。基于事件的系统依赖于接收事件的系统自己判断该做什么，其协作逻辑是分布在不同的协作者中，因此耦合度低。



5. 编排与协同

编排，依赖于某个中心来驱动流程。而协同依靠各个部分主动协作共同完成。编排的好处在于系统实现简单，便于追踪问题。缺点是中心控制节点承担太多职责，其它服务沦为CRUD贫血服务。协同的优点在于能消除耦合。缺点是需要额外工作来监控流程，增加系统复杂度。另外，如果想用请求/相应风格的语义，又想避免耗时业务时的长等待，可以采用异步请求加回调的方式。



6. 远程过程调用

远程过程调用（RPC）种类很多，一些依赖于接口定义（SOAP、Thrift、protocol buffers等），容易生成客户端和服务端的桩代码，用户可以快速编程。但其代价大于快速启动的好处。

技术的耦合。Java RMI，双方必须使用Java。Thrift和protocol buffers支持不同语言，一定程度上减轻了该问题。有时候RPC技术对于互操作性有一定的限制。

本地调用和远程调用并不相同。RPC面临网络的不确定性，还要进行载荷消息的封装和解封装。用户在使用时需要额外考虑网络带来的问题，而当作本地调用时又会带来考虑不全的问题。在进行RPC调用的错误处理时，显然要麻烦的多。

脆弱性。以Java RMI为例，接口修改就要导致桩代码的修改。

RPC很糟糕吗。尽量避免使用RMI，转为使用现代的RPC如protocol buffers或者Thrift。使用RPC时，不要对远程调用过度抽象，以至于网络因素都被隐藏了；确保可以独立升级服务端接口而不用客户端强制升级；在客户端中不要隐藏是在做网络调用这个事实。



7. REST

REST使得资源在服务内和在服务对外提供的形式可以不一样，解耦了。建议看Richardson的成熟度模型（http://martinfowler.com/articles/richardsonMaturityModel.html）。 REST没有规定底层协议，常用的是HTTP，也可以使用其它协议如串口或USB。HTTP上实现REST简单。

REST和HTTP。REST声明了一组对资源的使用方法，HTTP中有方法能与其对应。HTTP有很多支撑工具和技术。比如Varnish是HTTP缓存代理，mod_proxy是负载均衡器，还有大量HTTP监控工具，还有安全认证机制和工具。

超媒体作为程序状态的引擎。超媒体是一块包含了其它内容链接的内容。客户端与服务端应该通过超媒体进行交互。通过超媒体可以隐藏服务端内部的更改，将客户端与服务端解耦。该方式的缺点是客户端和服务端之间通信次数较多。但还是建议客户端自行发现遍历和发现API，因为这样可以解耦，不要过早优化。

JSON、XML和其他。JSON简单，内容更紧凑，比XML流行。但XML中有超链接来进行超媒体控制，JSON中没有，于是JSON有不同的自定义方式，如HAL标准。XML工具有更好支撑，提取负载特定部分可以使用XPATH工具，挺多，CSS选择器也可以用。JSON可以使用JSONPATH。

留心过多的约定。有些工具使用RESTFul Web服务框架把内部存储暴露给消费者，并不好。

基于HTTP的REST的缺点。无法像RPC一样帮助生成客户端代码。不要回到基于HTTP进行RPC的老路去构建共享库。另外，性能上的问题：基于HTTP的REST支持多种格式，如JSON或二进制，比SOAP强，但没法和Thrift这样的二进制协议比。对于低延迟通信或较小尺寸的消息不是一个好选择。不支持高级的序列化和反序列化。建议阅读《REST实战》这本书。



8. 实现基于事件的异步协作方式

技术选择。需要考虑微服务发布事件机制和消费者接收事件机制。RabbitMQ这样的消息代理可以解决上述问题，是个好选择。但尽量让这种消息中间件简单，逻辑放在自己的服务中，企业级服务总线是个不好的反例。在HTTP上，有ATOM这个符合REST规范的协议，可以用来提供资源聚合的发布服务。但是有消息中间件的话，还是建议使用消息中间件。

异步架构的复杂性。事件驱动的异步系统耦合度低，伸缩性好，但需要程序员转换思维模式，而且复杂性更高。要考虑各个流程有很好的监督，并考虑使用关联ID，它可以对跨进程请求进行追踪。强烈推荐《企业集成模式》这本书。



9. 服务即状态机。要把关键领域的生命周期显式地用状态机建模出来，避免出现贫血服务。



10. 响应式扩展（Reactive extensions, Rx）。它提供了一种机制，可以把多个调用结果组装起来并在此基础上执行操作。调用本身可以是阻塞或非阻塞的。当需要做一些基于多个服务调用的操作时，可以尝试它，它让代码更加简单。



11. 微服务世界中的DRY和代码重用的危险。Don’t Repeat Yourself，DRY可以得到重用性比较好的代码，可以创建一个共享库。但这在微服务中会导致服务和消费者之间过度耦合。在微服务内部不要违反DRY，在跨服务的情况下可以适当违反DRY。

客户端库。客户端库可以对服务开发进行一些封装，提升开发效率，避免重复的与服务交互的代码。但当开发服务端API和客户端API是同一拨人时，存在将服务逻辑引入客户端的问题，带来了耦合性的问题。如果要使用客户端，让它只处理底层传输协议（服务发现、故障处理等），不要加入服务逻辑。另外，客户端库可能会限制不同技术的使用。



12. 按引用访问。如果对访问的资源有本地缓存，要考虑资源的过期失效问题，确保同时有一个指向原始资源的引用。



13. 版本管理

尽可能推迟。避免过早将客户端与服务端紧密绑定。客户端要尽可能灵活消费服务响应，这符合Postel法则（系统中的每个模块都应该“宽进严出”）。例如客户端可以使用XPath从服务响应中提取需要的字段，即使字段位置改变也能正确读取（容错性读取器）。

及早发现破坏性修改。建议使用消费者驱动的契约来及早定位对消费者产生的破坏性修改。

使用语义化的版本管理。语义化版本管理使得客户端仅通过查看版本号就能知道是否能与之集成。版本好：MAJOR.MINOR.PATCH。MAJOR改变意味着包含向后不兼容的修改，客户端就不能直接集成。MINOR变化意味着新功能增加，向后兼容，客户端可以直接集成。PATCH变化意味着功能缺陷修复。

不同的接口共存。接口不可避免要修改时，保留老接口，提供新接口，二者共存。给消费者时间将老接口替换为新接口的使用，然后再删除老接口。另外，可以通过将老接口的请求转换为新接口的调用。不同版本共存时，可以在请求信息中增加版本标识，也可以在URI中增加版本标识。

同时使用多个版本的服务。为了支持老用户，有时候会使用多个版本的服务共存（注意，这里不是指服务接口，而是指服务本身）。短期内合理，但更应该考虑一个服务暴露两套API，而不是两个服务共存。



14. 用户界面

走向数字化。通过微服务的不同组合为桌面应用、移动端设备、可穿戴设备提供不同的体验。

约束。不同平台（桌面端、移动端）有不同的约束，屏幕解析度、通信方式、带宽、电池电量、UI操作。

API组合。 不同平台的API可以使用API入口（gateway），多个底层的调用会被聚合成一个调用。

UI片段的组合。相比UI主动访问所有API，再同步状态到UI控件上，更好的方法可能是服务直接暴露一部分UI，然后将这些组合到一起形成整体UI。可使用服务端模板的技术将这些片段组装起来。优势是修改服务的同时可以维护这些UI片段。

为前端服务的后端。服务端的聚合接口或API入口不要太厚重，要分成不同的后端，每个后端只为一个应用或用户界面服务（BFF， Backends for Frontends）。

一种混合方式。片段组装、BFF等可以权衡混合使用。



15. 与第三方软件集成。

使用一些商业的第三方软件会有如下问题：

缺乏控制。只有软件的厂家才能控制其发展和进行技术决策。

定制化。定制化很昂贵。

意大利面式的集成。一团乱麻的服务集成。

推荐的集成方式：

在自己可控的平台进行定制化。推荐这么做，可以使用自己的服务包住第三方的服务。

绞杀者模式（Strangler Application Pattern, http://martinfowler.com/bliki/StranglerApplication.html），拦截对老系统的调用，把调用路由到现存的遗留代码还是新写的代码，然后逐步替换老系统。一般使用一系列的微服务来拦截，而不是单一的单块应用

# 第五章 分解单块系统
1. 关键是接缝。Michael Feathers在《修改代码的艺术》一书中定义了接缝的概念。从接缝处可以抽取出相对独立的一部分代码，对这部分代码进行修改不会影响系统的其他部分。接缝即边界，前面说的限界上下文就是一个比较好的接缝。

2. 分解MusicCorp。MusicCorp是书中举的一个例子。根据业务识别出高层限界上下文。创建包结构表示这些上下文，把对应的代码挪过去。分析包之间的依赖关系，要和组织架构相匹配。使代码围绕接缝组织起来。

3. 分解单块系统的 原因。要考虑分解的速度、团队结构、安全审计、某些特殊技术实现的功能单独形成一个服务等因素。

4. 杂乱的依赖。

要使拉出来的接缝尽量少被其他组件依赖。

5. 数据库。不要用数据库集成。找到数据库中的接缝，分离出来。

6. 找到问题的关键。把数据库映射相关的代码和功能代码放在同一个上下文，根据业务来组织。另外，数据库表和表之间有约束，可以通过工具来可视化这些约束，如SchemaSpy(http://schemaspy.sourceforge.net)。

7. 例子：打破外键关系。将对属于其它上下文的表的访问转变为对其服务的访问，放弃外键关联，如果需要可以将约束从数据库转移到代码。

8. 例子：共享静态数据。像国家代码这种存在数据库的情况，可以用三种方法解决：每个包复制一份该表；这些共享静态数据放入代码（如属性文件或一个枚举），比数据库修改简单；静态数据放入一个单独的服务（有些极端）。推荐第二种。

9. 例子：共享数据。共享数据可以创建一个单独的包，提供该共享数据的服务。业务概念显性化了。

10. 例子：共享表。不同上下文的共享表按上下文实际需要的信息分开。

11. 重构数据库。数据库分离操作具体可参见Scott J. Ambler和Pramod J. Sadalage编写的Refactoring Databases。推荐先分离数据库，别先着急分离服务，观察一下效果，再考虑是否分离服务。

12. 事物边界。使用单块表结构，可以通过事务来保证多个操作的全部完成或全部回退。但按服务分表之后，无法使用事务来提供保证了。那应该怎么办呢？

再试一次。可以把操作放在队列或日志中，之后再尝试触发。最终一致性。

终止整个操作。通过补偿事务来抵消之前的操作，可能还需要重试补偿事务。

分布式事务。手动编排补偿事务会比较难，可以采用分布式事务，使用事务管理器来统一编配。处理分布式事务常用算法：两阶段提交。投票，根据投票结果实施。不要自己实现，尽量使用现有实现。

应该怎么办呢。上述方法会增加复杂性。要考虑是否一定要一致性，还是最终一致性就能满足业务需求。最终一致性的系统构建和扩展都更容易。如果一定要一致性，可以显式创建一个概念来表示这个服务，这样更容易实现补偿事务等操作。

13. 报告。存储分离后，需要考虑报告会出现的问题。

14. 报告数据库。报告需要获得各个部分的数据生出输出。在单块系统中，数据在一个数据库中，报告所需要的数据容易获得。

15. 通过服务调用来获取数据。依赖API调用获取数据只适合简单报告系统。使用SQL接口的问题在于不同的微服务暴露的API不一定能够很好适用于报告场景。缓存能够加快访问速度，但也会有无法命中的情况。可以通过提供批量API来简化过程，批量请求变为一个资源，处理好后通过共享文件给调用系统获取，减少HTTP开销。不过作者认为应该有更简单的方式。

16. 数据导出。使用一个独立的程序直接访问其他服务使用的数据库，把这些数据库导出到单独的报告数据库。虽然该程序成为了一个数据库集成程序，违反了低耦合原则，但它使得报告很简单，因此可以接受。可以通过维护团队负责将服务数据库的数据导出到报告系统数据库，缓解耦合性。也可以通过数据库技术，如使用视图创建一个聚合，使得对于报告系统来说看到的是单块数据表，但修改数据库时会增加复杂性。还是建议数据导出方式。

17. 事件数据导出。对于服务发出的事件可以通过事件订阅器导入到报告数据库中，比周期导入更及时，而且能够将服务内部实现和报告系统解耦。缺点是所需要的信息都要以事件形式广播出去，数据量大时，不容易像数据导出那样在数据库级别进行扩展。

18. 数据导出的备份。Netflix使用Cassandra作为数据备份的标准方式，开源了Aegisthus项目（一个能够处理大量数据的流水线）。

19. 走向实时。可以考虑将不同的数据按需路由到不同地方。

20. 修改的代价。做小的、增量的修改。可以用白板便于思考。可以用CRC（类-职责-交互）卡片帮助设计。

21. 理解根本原因。服务一定会慢慢变大，大到需要拆分。要及时发现需要拆分的时机