
## Hibernate中Java对象的状态有哪些 ##



#### Transient ####
对象具有以下特点


1. 没有和session关联的对象
2. 在数据库中不存在与之对应的记录

通常在下列情况下对象会进入临时状态


1. 刚刚创建的对象，还没有被持久化

2. 执行delete()方法，对于游离状态的对象，delete()方法会将其与数据库中对应的记录删除，而对于持久化状态的对象，delete方法会将其与数据库中对应的记录删除，并将其在Session中的缓存删除
3. 
#### Persistent ####
对象具有以下特点

1. 和seesion关联，在session缓存中
2. 在数据库中有与之对应的记录
3. session在清理缓存的时候，会根据持久化对象的属性变化更新数据库。

通常在下列情况下对象会进入临时状态 

1. 执行save()或saveOrUpdate()方法，使临时对象转变为持久化对象。
2. 执行upda()或saveOrUpdate()方法，使游离对象转变为持久化对象。
3. 执行load()或get()方法，返回的对象都是持久化对象
4. 执行find()方法，返回List集合中存放的都是持久化对象
5. 在允许级联保存的情况下，Session在清理缓存时会把与持久化对象关联的临时对象转变为持久化对象


#### Detached ####
对象具有以下特点

1. 对象不再Session缓存中，不予任何Session实例关联
2. 在数据库中有与之对应的记录

通常载下列情况对象会进入临时装填

1. 执行close()方法，将Session缓存清空，缓存中的所有持久化对象将转变成游离对象
2. 执行evict()方法，能从缓存中删除一个持久化对象，使之转变成游离对象


## HIbernate中get和load有什么不同之处 ##

> 如果缓存中咩有找到相应的对象，get将会直接访问数据库并返回一个完全初始化好的对象，而这个过程有可能涉及到多个数据调用。而load方法在缓存中没有发现对象的情况下，只会返回一个代理对象。只有在对象getId()之外的其他方法被调用时才会真正的去访问数据库，这样就能在某些情况下大幅度提高性能。

## SessionFactory是线程安全的吗 ##

> SessionFactory是在应用启动是就创建好的，对于单个的数据存储，一般只有一个SessionFacotory实例，所有的客户请求的线程都是通过这个工厂来获得Session，所以必须保证他是线程安全的。而Session不是线程安全的

## 一二级缓存区别及适用情况 ##

> 一级缓存是session级别的缓存，二级缓存是SessionFactory级别的缓存。
 以下数据适合放在二级缓存中

1. 很少被修改的数据
2. 不是很重要的数据，允许出现偶尔并发的数据
3. 不会被并发访问的数据

## 为什么Hibernate的实体类中需要提供一个无参的构造器 ##
> 因为Hibernate框架需要使用Reflection API，通过调用Class.newInstance()来创建这些实体类的实例。

## Hibernate是如何实现延迟加载的 ##
Hibernate使用代理模式实现延迟加载，在load一个对象，或者存在级联对象时使用延迟加载的机制时。Hiberante会动态的创建一个这个对象的代理对象。当真正访问对象的属性时才会真正的发起数据库请求初始化对象的细节














